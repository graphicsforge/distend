var http = require('http'), // HTTP server
    net = require('net'),
    os = require('os'),
    io = require('socket.io'), // Socket.io
    path = require('path');


var MSG_SERVER_PORT;

var clients = [];
var clientaliases = [];
var channels = [];
var nextIndex = 1;


var notifyServer = net.createServer(function (socket) {
  socket.setEncoding('ascii');
  var clientNotifyCallback = function(data, channel) {
    if ( channel!=undefined )
    {
      if ( typeof(channel)=='string' )  // if we got a string, normalize it into an array of strings
      {
        // we'll usually get '\'' from SELECTing tsvectors, so remove those
        channel = channel.replace(/\'/g, '');
        if ( channel.indexOf(',')!=-1 )
          channel = channel.split(',');
        else if( channel.indexOf(' ')!=-1 )
          channel = channel.split(' ');
        else
          channel = [channel.slice()];
      }
      // walk through channels list and see how the current msg channel evaluates
      for ( var i=0; i<channels[socket.index].length; i++ )
      {
        if ( !channels[socket.index][i].length )
          continue;
        // TODO assuming that this is preformatted so that there are spaces between each term
        var subscription = channels[socket.index][i].split(' ');
        for ( var ii=0; ii<subscription.length; ii++ )
        {
          if ( subscription[ii].length>2 )  // TODO actually regex off the contents maybe?
          {
            var negated = (subscription[ii][0]=='!');
            if ( negated )
              subscription[ii] = subscription[ii].slice(1);
            subscription[ii] = "channel.indexOf('"+subscription[ii]+"')";
            if ( negated )
              subscription[ii] = subscription[ii]+"==-1";
            else
              subscription[ii] = subscription[ii]+"!=-1";
          }
        }
        var subscription = subscription.join(' ');
        subscription = subscription.replace(/ & /g," && ").replace(/ \| /g," || ");
        try {
          if ( subscription!=undefined && subscription.length && eval(subscription) )
          {
            socket.write(data);
            break;
          }
        } catch (error) {}
      }
    }
    else
      try {
        socket.write(data);
      } catch (error) {}
  };

  socket.addListener("connect", function() {
    var index = nextIndex;
    // make sure we grab a new index
    while ( clients[index]!=undefined )
    {
      index += 1;
      if ( index >= Number.MAX_VALUE )
        index = 1;
    }
    nextIndex = index + 1;
    clientalias = "anon"+index.toString();
    socket.index = index;
    clients[index] = socket;
    clientaliases[index] = clientalias;
    if ( channels[index]==undefined )
      channels[index] = [];
    if ( !(clientalias in channels[index]) )
      channels[index].push( clientalias );
    socket.addListener("notify", clientNotifyCallback);
    // send system notification that we're here
    for ( var i=0; i<clients.length; i++ )
      try {
        clients[i].emit("notify", clientaliases[socket.index]+"\tconnect\n", "system");
        clients[i].emit("notify", "/statusBox\tadd\t"+clientaliases[socket.index]+"\n", "statusBox"); 
      } catch (error) {}
    console.log(clientaliases[index]+" connected from "+socket.remoteAddress);
  });

  socket.on("data", function(data) {
    var lines = data.split("\r");
    var lines = lines[0].split("\n");
    var tabs = lines[0].split("\t");
    var delimited = tabs;
    var delimiter = '\t';
    if ( tabs.length<3 )
    {
      delimited = lines[0].split(" ");
      delimiter = ' ';
    }
    if ( delimited[0][0]=='/' )
    {
      // check for channel subscription changes
      if ( delimited[0]=="/join" && delimited[1]!=undefined )
      {
        // TODO force formatting on channel name so we can keep evaluation simple
        console.log( clientaliases[socket.index]+" is joining "+lines[0].slice(6) );
        if ( !( lines[0].slice(6) in channels[socket.index]) )
          channels[socket.index].push( lines[0].slice(6) );
      }
      else if ( delimited[0]=="/part" && delimited[1]!=undefined )
      {
        if ( channels[socket.index].indexOf( lines[0].slice(6) )>=0 )
          channels[socket.index].splice(channels[socket.index].indexOf( lines[0].slice(6) ), 1);
      }
      else if ( delimited[0]=="/nick" && delimited[1]!=undefined )
      {
        // unsubscribe from prev id's channel
        if ( channels[socket.index].indexOf( clientaliases[socket.index] )>=0 )
        {
          for ( var i=0; i<clients.length; i++ )
            try {
              clients[i].emit("notify", delimited[1]+"\twas known as\t"+clientaliases[socket.index]+"\n", "system"); 
              clients[i].emit("notify", "/statusBox\trename\t"+clientaliases[socket.index]+" "+delimited[1]+"\n", "statusBox"); 
  clients[i].emit("notify", "statusBox\trename\t"+clientaliases[socket.index]+" "+delimited[1]+"\n", "statusBox"); 
            } catch (error) {}
          channels[socket.index][channels[socket.index].indexOf( clientaliases[socket.index] )] = "";
        }
        if ( true || !(delimited[1] in clientaliases) )  // allow multiple clients to be the same nick?
        {
          clientaliases[socket.index] = delimited[1];
          if ( !( delimited[1] in channels[socket.index]) )
            channels[socket.index].push( delimited[1] );
        }
      }
      else if ( delimited[0]=="/whoami" )
        socket.emit( "notify", clientaliases[socket.index]+"\n" );
      else if ( delimited[0]=="/who" || delimited[0]=="/users" )
      {
        var outputmsg = ""
        clientaliases.forEach(function(value, key){ if(value!=undefined){outputmsg+=value+" ";} });
        try {
        socket.write( outputmsg+"\n" );
        } catch (error) {}
      }
      else if ( delimited[0]=="/channels" )
        try {
        socket.write( channels[socket.index].join(",")+"\n" );
        } catch (error) {}
      else if ( (delimited[0]=="/msg"||delimited[0]=="/m") && delimited[1]!=undefined )
      {
        var outputmsg = delimited.slice(2).join(delimiter)+"\n";
        for ( var i=0; i<clients.length; i++ )
          try {
          clients[i].emit("notify", outputmsg, delimited[1]);
          } catch (error) {}
      }
      else if ( delimited[0]=="/me" )
      {
        var outputmsg = clientaliases[socket.index]+":"+delimiter+delimited.slice(1).join(delimiter)+"\n";
        for ( var i=0; i<clients.length; i++ )
          try {
          clients[i].emit("notify", outputmsg);
          } catch (error) {}
      }
      else if ( delimited[0]=="/slap" )
      {
        // TODO make sure people are signed in before they can be slapped?
        var outputmsg = clientaliases[socket.index]+" slaps "+delimited[1]+" around a bit with a large trout... ";
        var damage = Math.round(Math.random()*125)-25;
        if ( damage<=0 )
          outputmsg += "but MISSES!\n";
        else if ( damage<20 )
          outputmsg += "but nicks for "+damage+" damage!\n";
        else if ( damage<75 )
          outputmsg += "and hits for "+damage+" damage\n";
        else
          outputmsg += "and CRITS for "+damage+" damage!!\n";
        for ( var i=0; i<clients.length; i++ )
          try {
          clients[i].emit("notify", outputmsg);
          } catch (error) {}
      }
      else if ( delimited[0]=="/quit" )
      {
        for ( var i=0; i<clients.length; i++ )
        if ( clients[i]!=undefined )
          clients[i].emit("notify", clientaliases[socket.index]+"\tdisconnecting\t"+delimited[1]+"\n", "system");
        socket.end( delimited[1]);
      }
      else if ( delimited[0]=="/ping" )
        socket.write( "pong\n" );
      else
      {
        for ( var i=0; i<clients.length; i++ )
          if ( i!=socket.index )
            try {
              clients[i].emit("notify", data);
            } catch (error) {}
      }
    }
    else if ( delimited[0]==clientaliases[socket.index] )
    {
      for ( var i=0; i<clients.length; i++ )
        try {
        clients[i].emit("notify", data, delimited[1]);
        } catch (error) {}
    }
    else
    {
      for ( var i=0; i<clients.length; i++ )
        if ( i!=socket.index )
          try {
            clients[i].emit("notify", data);
          } catch (error) {}
    }
    // deal with subsquent lines eating an endline if needed
    if( lines.length>1 && lines[1].length>1 )
    {
      if( lines.slice(1)[1]=='\n' )
        socket.emit("data", lines.slice(1).join("\n").slice(1));
      else
        socket.emit("data", lines.slice(1).join("\n"));
    }
  });

  socket.on("error", function(err) {
    console.log(err.code);
  });

  socket.on("close", function() {
    socket.removeListener("notify", clientNotifyCallback);
    console.log("closed connection from ["+clientaliases[socket.index]+"@"+socket.remoteAddress+"]");
    // send system notification that we're gone
    for ( var i=0; i<clients.length; i++ )
      if ( clients[i]!=undefined ){
        clients[i].emit("notify", clientaliases[socket.index]+"\tis no longer available\n", "statusBox");
          clients[i].emit("notify", "/statusBox\tremove\t"+clientaliases[socket.index]+"\n", "statusBox");
      }
    clients[socket.index] = undefined;
    clientaliases[socket.index] = undefined;
    channels[socket.index] = undefined;
  });
})
notifyServer.on('error', function(err){
  console.log("notifyServer "+err.code);
});

module.exports = {
  setPort: function(port){
    MSG_SERVER_PORT = port;
  },
  getPort: function(){
    return MSG_SERVER_PORT;
  },
  startServer: function(){
    notifyServer.listen(MSG_SERVER_PORT);
    console.log( "starting chat server on "+MSG_SERVER_PORT );
  },
  getClientAliases: function(){
    var response = "";
    for ( i=0; i<clientaliases.length; i++ )
    {
      if ( clientaliases[i]!=undefined )
      {
        response+=clientaliases[i];
        response+=" ";
      }
    }
    return response;
  },
  write: function( data, channels ) {
    for ( var i=0; i<clients.length; i++ )
      try {
      clients[i].emit("notify", data, channels);
      } catch (error) {}
  }

}
