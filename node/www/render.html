
<script type="text/javascript" src="camera.js"></script>
<script type="text/javascript" src="canvasMatrix.js"></script>
<script type="text/javascript" src="model.js"></script>
<script>

  Renderer.prototype.displayloop = function()
  {
    if ( true ) //autorotate
    {
      this.camera.rotate([0,.5,0]);
      this.camera.translate([0.05,0,0]);
      this.dirty = true;
    }
    this.drawGL();
    var self = this;
    setTimeout(function(){self.displayloop();}, 10);
  }

  function Renderer()
  {
    this.dirty = true;
    this.doLoad();
  }

  function getShader( gl, id )
  {
    var shaderScript = document.getElementById ( id );
    var str = "";
    var k = shaderScript.firstChild;
    while ( k ){
     if ( k.nodeType == 3 ) str += k.textContent;
     k = k.nextSibling;
    }
    var shader;
    if ( shaderScript.type == "x-shader/x-fragment" )
           shader = gl.createShader ( gl.FRAGMENT_SHADER );
    else if ( shaderScript.type == "x-shader/x-vertex" )
           shader = gl.createShader(gl.VERTEX_SHADER);
    else return null;
    gl.shaderSource(shader, str);
    gl.compileShader(shader);
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)
    {
      alert("error on shader:"+id+" "+gl.getShaderInfoLog(shader));
    }
    return shader;
  }

Renderer.prototype.initTextures = function()
{
  this.textureLoadAttempts = 0;
  this.testTexture = this.gl.createTexture();
  this.testImage = new Image();
  var obj = this;
if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1)
{
//this.testImage.addEventListener('load', setTimeout( function(){ obj.textureLoaded( obj.testTexture, obj.testImage ); }, 100 ) );
this.testImage.addEventListener('load', function(){ obj.textureLoaded( obj.testTexture, obj.testImage ); }, false );
}
else
this.testImage.addEventListener('load', function(){ obj.textureLoaded( obj.testTexture, obj.testImage ); }, false );
  this.testImage.src = "test.jpg";
}

Renderer.prototype.textureLoaded = function( texture, image )
{
  var obj = this;
  var gl = this.gl;
  try {
    if ( texture==undefined )
      texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    this.dirty = true;
  } catch (error) { if ( obj.textureLoadAttempts<10 ) { document.getElementById('debug').innerHTML=obj.textureLoadAttempts+error; obj.textureLoadAttempts++; setTimeout( function(){obj.textureLoaded(texture, image)}, 1000 ); } else {alert(error);} return; }
}

Renderer.prototype.onResize = function()
{
  this.canvas = document.getElementById('renderer_canvas');
  if ( this.canvas==undefined )
    return;
  this.canvas.style.height = document.body.clientHeight-150;
  this.canvas.style.width = parseInt(document.body.clientWidth/2)-10;
  // reshape canvas contents
  this.canvas.width = parseInt(this.canvas.style.width);
  this.canvas.height = parseInt(this.canvas.style.height);
  this.dirty = true;
}


  Renderer.prototype.initGL = function()
  {
    var gl = this.gl;
    // matrixes
    this.camera = new Camera();
    this.prMatrix = new CanvasMatrix4();
    this.mvMatrix = new CanvasMatrix4();
    // application setup
    this.videoAlpha = 1;
    // shaders
    this.prog = gl.createProgram();
    var prog = this.prog;
    gl.attachShader(prog, getShader( gl, "vs-basic" ));
    gl.attachShader(prog, getShader( gl, "fs-basic" ));
    gl.linkProgram(prog);
    gl.useProgram(prog);
    this.posLoc = gl.getAttribLocation(prog, "aPos");
    gl.enableVertexAttribArray( this.posLoc );
    this.normLoc = gl.getAttribLocation(prog, "aNorm");
    gl.enableVertexAttribArray( this.normLoc );
    this.texLoc = gl.getAttribLocation(prog, "aTexCoord");
    gl.enableVertexAttribArray( this.texLoc );
    gl.uniform1f(gl.getUniformLocation(prog, "alpha"), 1);
    // opengl settings
    gl.clearColor(0.5, 0.5, 0.5, 1);
    gl.clearDepth(1);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.BLEND);
    gl.enable( gl.DEPTH_TEST );
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    this.models = [];
    this.models['test'] = new Model(gl, '/test.json');
    this.models['square'] = new Model(gl, '/square.json');

    // initialize shader transform variables
    this.vs_basic_prMatrix = gl.getUniformLocation(prog, "prMatrix");
    this.vs_basic_mvMatrix = gl.getUniformLocation(prog, "mvMatrix");
  }

  Renderer.prototype.doLoad = function()
  {
    this.canvas = document.getElementById("renderer_canvas");
    var self = this;
    if ( this.canvas==undefined )
      return setTimeout(function(){self.doLoad();}, 10);

    this.canvas.width = parseInt(this.canvas.style.width);
    this.canvas.height = parseInt(this.canvas.style.height);

    this.gl = this.canvas.getContext("experimental-webgl");
    if ( !this.gl )
    {
      alert("Warning: no webGL context available!");
      return;
    }
    this.initGL();
    this.initTextures();
    this.dirty = true;
    // starting displayloop
    this.displayloop();
  }


  Renderer.prototype.drawGL = function()
  {
    if ( !this.gl )
      return 0;
    // check if we're marked for a redraw before doing anything
    if ( typeof(this.dirty)!='undefined' && this.dirty!=undefined && this.dirty==false )
      return 1;
    this.dirty = false;
    var gl = this.gl;
    var prMatrix = this.prMatrix;
    var mvMatrix = this.mvMatrix;
    var camera = this.camera;

    // TODO: check to see if we're loaded yet
    // set up viewport
    gl.viewport( 0, 0, this.canvas.width, this.canvas.height );
    // set up scene
    gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

    // setup background texture, 2D origin in centre
    prMatrix.makeIdentity();
    prMatrix.ortho(-.5, .5, .5, -.5, -1, 1);
    gl.uniformMatrix4fv( this.vs_basic_prMatrix, false, new Float32Array(prMatrix.getAsArray()) );
    mvMatrix.makeIdentity();
    mvMatrix.translate(-.5, -.5, 0);
    var backgroundAspectRatio = (parseInt(this.canvas.height)/parseInt(this.canvas.width) * this.testImage.width/this.testImage.height);   // maintain aspect ratio
    if ( backgroundAspectRatio>=1 )
      mvMatrix.scale( backgroundAspectRatio, 1, 1 );
    else
      mvMatrix.scale( 1, 1/backgroundAspectRatio, 1 );
    gl.uniformMatrix4fv( this.vs_basic_mvMatrix, false, new Float32Array(mvMatrix.getAsArray()) );
    gl.uniform1f(gl.getUniformLocation(this.prog, "alpha"), 1);

    gl.bindTexture(gl.TEXTURE_2D, this.testTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    this.models['square'].draw(gl, this.posLoc, this.normLoc, this.texLoc);

    gl.clear( gl.DEPTH_BUFFER_BIT )

    // draw 3D scene
    prMatrix.makeIdentity();
    prMatrix.perspective(camera.vfov, this.canvas.width/this.canvas.height*camera.pixelAspectRatio, camera.frustrumNear, camera.frustrumFar);
    gl.uniformMatrix4fv( this.vs_basic_prMatrix, false, new Float32Array(prMatrix.getAsArray()) );
    gl.uniform1f(gl.getUniformLocation(this.prog, "alpha"), .9);
    mvMatrix.makeIdentity();
    mvMatrix.rotate(90, 1,0,0);
    mvMatrix.multRight(camera.extrinsic);
    gl.uniformMatrix4fv( this.vs_basic_mvMatrix, false, new Float32Array(mvMatrix.getAsArray()) );

    gl.bindTexture(gl.TEXTURE_2D, this.testTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    this.models['test'].draw(gl, this.posLoc, this.normLoc, this.texLoc);

    gl.bindTexture(gl.TEXTURE_2D, null);

  }



var renderer;
renderer = new Renderer();
</script>

<canvas style="position:absolute;width:300px;height:300px;right:0px;bottom:0px;" id="renderer_canvas" oncontextmenu="return false;"></canvas>
