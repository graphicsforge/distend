
<script type="text/javascript" src="camera.js"></script>
<script type="text/javascript" src="canvasMatrix.js"></script>
<script type="text/javascript" src="model.js"></script>
<script type="text/javascript" src="texture.js"></script>
<script>

  Renderer.prototype.displayloop = function()
  {
    if ( true ) //autorotate
    {
      this.camera.rotate([0,.5,0]);
      this.camera.translate([0.05,0,0]);
      this.dirty = true;
    }
    this.drawGL();
    var self = this;
    setTimeout(function(){self.displayloop();}, 10);
  }

  function Renderer()
  {
    this.dirty = true;
    this.doLoad();
  }

  function getShader( gl, id )
  {
    var shaderScript = document.getElementById ( id );
    var str = "";
    var k = shaderScript.firstChild;
    while ( k ){
     if ( k.nodeType == 3 ) str += k.textContent;
     k = k.nextSibling;
    }
    var shader;
    if ( shaderScript.type == "x-shader/x-fragment" )
           shader = gl.createShader ( gl.FRAGMENT_SHADER );
    else if ( shaderScript.type == "x-shader/x-vertex" )
           shader = gl.createShader(gl.VERTEX_SHADER);
    else return null;
    gl.shaderSource(shader, str);
    gl.compileShader(shader);
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)
    {
      alert("error on shader:"+id+" "+gl.getShaderInfoLog(shader));
    }
    return shader;
  }

  Renderer.prototype.initGL = function()
  {
    var gl = this.gl;
    // matrixes
    this.camera = new Camera();
    this.prMatrix = new CanvasMatrix4();
    this.mvMatrix = new CanvasMatrix4();
    // application setup
    this.videoAlpha = 1;
    // shaders
    this.prog = gl.createProgram();
    var prog = this.prog;
    gl.attachShader(prog, getShader( gl, "vs-basic" ));
    gl.attachShader(prog, getShader( gl, "fs-basic" ));
    gl.linkProgram(prog);
    gl.useProgram(prog);
    this.posLoc = gl.getAttribLocation(prog, "aPos");
    gl.enableVertexAttribArray( this.posLoc );
    this.normLoc = gl.getAttribLocation(prog, "aNorm");
    gl.enableVertexAttribArray( this.normLoc );
    this.texLoc = gl.getAttribLocation(prog, "aTexCoord");
    gl.enableVertexAttribArray( this.texLoc );
    gl.uniform1f(gl.getUniformLocation(prog, "alpha"), 1);
    // initialize shader transform variables
    this.vs_basic_prMatrix = gl.getUniformLocation(prog, "prMatrix");
    this.vs_basic_mvMatrix = gl.getUniformLocation(prog, "mvMatrix");
    // opengl settings
    gl.clearColor(0.5, 0.5, 0.5, 1);
    gl.clearDepth(1);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.BLEND);
    gl.enable( gl.DEPTH_TEST );
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    // load models
    this.models = [];
    this.models['test'] = new Model(gl, '/test.json');
    this.models['square'] = new Model(gl, '/square.json');
    // load textures
    this.textures = [];
    this.textures['test'] = new Texture(gl, '/test.jpg');
  }

  Renderer.prototype.doLoad = function()
  {
    this.canvas = document.getElementById("renderer_canvas");
    var self = this;
    // wait until such a dom element exists
    if ( this.canvas==undefined )
      return setTimeout(function(){self.doLoad();}, 10);
    // attach ui listeners
    if ( uiManager!=undefined )
    {
      this.canvasPos = UIManager.getOffset(this.canvas);
      uiManager.addListener('mousemove', this.onMouseMove, self);
      uiManager.addListener('resize', this.onResize, self);
    }
    this.canvas.width = parseInt(this.canvas.style.width);
    this.canvas.height = parseInt(this.canvas.style.height);
    // generate webgl context
    this.gl = this.canvas.getContext("experimental-webgl");
    if ( !this.gl )
    {
      alert("Warning: no webGL context available!");
      return;
    }
    this.initGL();
    this.dirty = true;
    // starting displayloop
    this.displayloop();
  }

  Renderer.prototype.onResize = function(event, self)
  {
    if ( self.canvas==undefined )
      return;
    self.canvasPos = UIManager.getOffset(self.canvas);
    //self.canvas.style.height = document.body.clientHeight-150;
    //self.canvas.style.width = parseInt(document.body.clientWidth/2)-10;
    // reshape canvas contents
    self.canvas.width = parseInt(self.canvas.style.width);
    self.canvas.height = parseInt(self.canvas.style.height);
    self.dirty = true;
  }

  Renderer.prototype.onMouseMove = function(event, self)
  {
    if ( self.canvas==undefined )
      return;
    // grab relative mouse position ( range -0.5 to 0.5 )
    self.mousePos = uiManager.mousePos.slice(0);
    self.mousePos[0] = (self.mousePos[0]-self.canvasPos[0])/self.canvas.width-0.5;
    self.mousePos[1] = (self.mousePos[1]-self.canvasPos[1])/self.canvas.height-0.5;
    self.dirty = true;
  }

  Renderer.prototype.drawGL = function()
  {
    if ( !this.gl )
      return 0;
    // check if we're marked for a redraw before doing anything
    if ( typeof(this.dirty)!='undefined' && this.dirty!=undefined && this.dirty==false )
      return 1;
    this.dirty = false;
    var gl = this.gl;
    var prMatrix = this.prMatrix;
    var mvMatrix = this.mvMatrix;
    var camera = this.camera;

    // TODO: check to see if we're loaded yet
    // set up viewport
    gl.viewport( 0, 0, this.canvas.width, this.canvas.height );
    // set up scene
    gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

    // setup background texture, 2D origin in centre
    prMatrix.makeIdentity();
    prMatrix.ortho(-.5, .5, .5, -.5, -1, 1);
    gl.uniformMatrix4fv( this.vs_basic_prMatrix, false, new Float32Array(prMatrix.getAsArray()) );
    mvMatrix.makeIdentity();
    mvMatrix.translate(-.5, -.5, 0);
    var backgroundAspectRatio = (parseInt(this.canvas.height)/parseInt(this.canvas.width) * this.textures['test'].aspect);   // maintain aspect ratio
    if ( backgroundAspectRatio>=1 )
      mvMatrix.scale( backgroundAspectRatio, 1, 1 );
    else
      mvMatrix.scale( 1, 1/backgroundAspectRatio, 1 );
    gl.uniformMatrix4fv( this.vs_basic_mvMatrix, false, new Float32Array(mvMatrix.getAsArray()) );
    gl.uniform1f(gl.getUniformLocation(this.prog, "alpha"), 1);

    this.textures['test'].bind(gl);
    this.models['square'].draw(gl, this.posLoc, this.normLoc, this.texLoc);

    gl.clear( gl.DEPTH_BUFFER_BIT )
    mvMatrix.makeIdentity();
    mvMatrix.scale( .1, .1, .1 );
    if ( this.mousePos )
      mvMatrix.translate(this.mousePos[0], this.mousePos[1], 0);
    gl.uniformMatrix4fv( this.vs_basic_mvMatrix, false, new Float32Array(mvMatrix.getAsArray()) );
    this.models['square'].draw(gl, this.posLoc, this.normLoc, this.texLoc);


    // draw 3D scene
    prMatrix.makeIdentity();
    prMatrix.perspective(camera.vfov, this.canvas.width/this.canvas.height*camera.pixelAspectRatio, camera.frustrumNear, camera.frustrumFar);
    gl.uniformMatrix4fv( this.vs_basic_prMatrix, false, new Float32Array(prMatrix.getAsArray()) );
    gl.uniform1f(gl.getUniformLocation(this.prog, "alpha"), .9);
    mvMatrix.makeIdentity();
    mvMatrix.rotate(90, 1,0,0);
    mvMatrix.multRight(camera.extrinsic);
    gl.uniformMatrix4fv( this.vs_basic_mvMatrix, false, new Float32Array(mvMatrix.getAsArray()) );

    this.textures['test'].bind(gl);
    this.models['test'].draw(gl, this.posLoc, this.normLoc, this.texLoc);

    gl.bindTexture(gl.TEXTURE_2D, null);

    gl.clear( gl.DEPTH_BUFFER_BIT )
  }



var renderer;
renderer = new Renderer();
</script>

<canvas style="position:absolute;width:300px;height:300px;right:0px;bottom:0px;" id="renderer_canvas" oncontextmenu="return false;"></canvas>
